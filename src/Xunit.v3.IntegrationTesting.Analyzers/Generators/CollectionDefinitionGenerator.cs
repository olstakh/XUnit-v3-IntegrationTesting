using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;
using Xunit.v3.IntegrationTesting.Analyzers.Helpers;

namespace Xunit.v3.IntegrationTesting.Analyzers.Generators;

[Generator(LanguageNames.CSharp)]
public class CollectionDefinitionGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValueProvider<ImmutableArray<object?>> data =
            context.SyntaxProvider

            // Find all MethodDeclarationSyntax nodes attributed with WrapWithLoggingAttribute and gather the required information.
            // The predicate will be run once for every attributed node in the same file that's being modified.
            // The transform will be run once for every attributed node in the compilation.
            // Thus, both should do the minimal amount of work required and get out.  This should also have extracted
            // everything from the target necessary to do all subsequent analysis and should return an object that's
            // meaningfully comparable and that doesn't reference anything from the compilation: we want to ensure
            // that any successful cached results are idempotent for the input such that they don't trigger downstream work
            // if there are no changes.

            .ForAttributeWithMetadataName(
                $"Xunit.v3.IntegrationTesting.DependsOnClassesAttribute",
                (node, _) => node is ClassDeclarationSyntax,
                GetCollectionOrDiagnostic)

            .Where(static x => x is not null)

            // Combine all of the generated text outputs into a single batch.
            .Collect()

            // Apply sequence equality comparison on the result array for incremental caching.
            .WithComparer(new ObjectImmutableArraySequenceEqualityComparer());

        context.RegisterSourceOutput(data, static (context, data) =>
        {
            var diagnostics = data.OfType<DiagnosticData>().ToList();
            foreach (var diagnostic in diagnostics)
            {
                context.ReportDiagnostic(diagnostic.ToDiagnostic());
            }

            if (diagnostics.Count == data.Length)
            {
                // Nothing to generate
                return;
            }

            context.AddSource("CollectionDefinitions.g.cs", SourceText.From($$"""
                // <auto-generated/>
                using System;

                {{string.Join("\r\n", data.OfType<CollectionDefinitionInfo>().Select(GenerateCollectionDefinitionCode))}}
                """, Encoding.UTF8));
        });
    }

    private static string GenerateCollectionDefinitionCode(CollectionDefinitionInfo info)
    {
        return $"""
            [Xunit.CollectionDefinition("{info.CollectionName}", DisableParallelization = true)]
            [Xunit.v3.IntegrationTesting.DependsOnCollections({info.Dependencies})]
            public sealed class Generated_CollectionDefinition_{info.ClassName};
            """;
    }

    private static readonly SymbolDisplayFormat s_format = new SymbolDisplayFormat(
        globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,
        typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
        genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
        miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier
    );

    private static object? GetCollectionOrDiagnostic(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
    {
        var attribute = context.Attributes.SingleOrDefault();
        if (attribute is null || attribute.AttributeClass is null)
        {
            // Should not happen, because attribute has 'AllowMultiple = false', so we'll delegate alerting to the compiler
            return null;
        }

        if (context.TargetNode is not ClassDeclarationSyntax classDeclaration || context.TargetSymbol is not INamedTypeSymbol classSymbol)
        {
            // Should not happen, because of the predicate in ForAttributeWithMetadataName, so we'll delegate alerting to the compiler
            return null;
        }

        // Get CollectionName argument
        var collectionNameArg = attribute.NamedArguments.FirstOrDefault(kvp => kvp.Key == "CollectionName").Value;
        if (collectionNameArg.Value is not string collectionName || string.IsNullOrWhiteSpace(collectionName))
        {
            // Report diagnostic: CollectionName is required and should be not empty
            return null;
        }

        // Get Dependencies argument
        var dependenciesArg = attribute.NamedArguments.FirstOrDefault(kvp => kvp.Key == "Dependencies").Value;
        var dependenciesConstants = dependenciesArg.Values;
        if (dependenciesConstants == null || !dependenciesConstants.Any())
        {
            // Report diagnostic: Dependencies is required and should be not empty
            return null;
        }

        // If we reached this point, we have valid CollectionName and Dependencies
        return new CollectionDefinitionInfo
        {
            CollectionName = collectionName,
            ClassName = classDeclaration.Identifier.Text,
            Dependencies = string.Join(", ", dependenciesConstants.Where(dc => dc.Value is not null).Select(dc => $"typeof({dc.Value!.ToString()})"))
        };
    }

    /// <summary>Stores the data necessary to create a Diagnostic.</summary>
    /// <remarks>
    /// Diagnostics do not have value equality semantics.  Storing them in an object model
    /// used in the pipeline can result in unnecessary recompilation.
    /// </remarks>
    private sealed record class DiagnosticData(DiagnosticDescriptor descriptor, Location location, object? arg = null)
    {
        /// <summary>Create a <see cref="Diagnostic"/> from the data.</summary>
        public Diagnostic ToDiagnostic() => Diagnostic.Create(descriptor, location, arg is null ? [] : [arg]);
    }

    private static Location GetComparableLocation(SyntaxTree syntaxTree, TextSpan span)
    {
        return Location.Create(
            syntaxTree,
            span);
    }

    private sealed record CollectionDefinitionInfo
    {
        public required string CollectionName { get; init; }
        public required string ClassName { get; init; }
        public required string Dependencies { get; init; }
    }
}